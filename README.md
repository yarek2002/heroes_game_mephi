# heroes_game_mephi
Реализация алгоритмов
Реализованы следующие интерфейсы из heroes_task_lib. 
1. GeneratePreset: Метод Army generate(List<Unit> unitList, int maxPoints)

Реализованный алгоритм: Жадный алгоритм. Сначала сортируем типы юнитов по убыванию соотношения атака/стоимость (для приоритета атаки). Затем для каждого типа добавляем максимальное количество юнитов (≤11 и ≤остатку очков), копируя шаблон юнита.
Расчёт алгоритмической сложности:
Этап 1: Сортировка списка типов юнитов (n=4) — O(n log n).
Этап 2: Для каждого типа (цикл по n) рассчитываем maxCount = min(11, maxPoints / cost) — O(n).
Этап 3: Добавление юнитов в армию (вложенный цикл, общее количество итераций ≤44) — O(k), где k≤44.
Итоговая сложность: O(n log n + k). Поскольку n=4 (константа), это O(k), что лучше или равно требуемой O(n * k).


2. SimulateBattle: Метод void simulate(Army playerArmy, Army computerArmy)

Реализованный алгоритм: В цикле while (пока обе армии имеют живых юнитов): собираем всех живых юнитов из обеих армий, сортируем по убыванию атаки, для каждого вызываем attack() и логируем результат через printBattleLog, если цель найдена. Юниты, погибшие в раунде, исключаются в следующих итерациях.
Расчёт алгоритмической сложности (принимая, что attack() работает за O(m), где m — общее юнитов):
Этап 1: Сбор живых юнитов — O(m).
Этап 2: Сортировка — O(m log m).
Этап 3: Цикл атак (for по m юнитам, каждая атака O(m)) — O(m²).
Количество раундов r ≤ m.
Итоговая сложность: O(r * (m log m + m²)) = O(m³), но при m≤88 практично и соответствует или лучше O(r * m²).


3. SuitableForAttackUnitsFinder: Метод List<Unit> getSuitableUnits(List<List<Unit>> unitsByRow, boolean isLeftArmyTarget)

Реализованный алгоритм: Для каждого ряда проходим по всем юнитам. Для каждого юнита проверяем все остальные юниты в том же ряду на наличие соседа по Y (слева/справа в зависимости от стороны). Если сосед не найден, добавляем юнита в список доступных для атаки.
Расчёт алгоритмической сложности:
Этап 1: Проход по всем рядам — O(r), где r=3.
Этап 2: Для каждого юнита проверка всех юнитов в ряду — O(m²) в худшем случае, где m — общее количество юнитов.
Итоговая сложность: O(m²). На практике, если юниты распределены равномерно по рядам, сложность может быть ближе к O(m), что соответствует или лучше требуемой.


4. UnitTargetPathFinder: Метод List<Edge> getTargetPath(Unit attackUnit, Unit targetUnit, List<Unit> existingUnitList)

Реализованный алгоритм: Алгоритм BFS (поиск в ширину) на графе-сетке 27x21 с 8 направлениями (диагонали разрешены). Препятствия — живые юниты кроме атакующего/цели. Используем Queue для посещения, boolean[][] массивы для visited и obstacles, HashMap для parent (ключ — строка "x:y"). Восстанавливаем путь по parent от цели к старту.
Расчёт алгоритмической сложности:
Этап 1: Построение массива препятствий — O(m), где m — количество юнитов.
Этап 2: BFS — O(WIDTH * HEIGHT) = O(567) в худшем случае.
Этап 3: Восстановление пути — O(длина пути) ≤ O(48).
Итоговая сложность: O(WIDTH * HEIGHT) = O(константа), соответствует или лучше требуемой.
